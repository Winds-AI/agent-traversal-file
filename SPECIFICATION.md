# IATF Format Specification v1.0

## 0. Overview: Auto-Indexing Workflow

IATF files use an **auto-generated index** approach to solve the line-number maintenance problem:

**Source of Truth**: CONTENT section (what you edit)
**Generated Cache**: INDEX section (auto-rebuilt by tools)

### Why Auto-Generation?

Manual line numbering is impractical:
- Edit section 2: add 10 lines
- Now sections 3, 4, 5... all need line number updates
- Error-prone, tedious, defeats the purpose

### How It Works

1. **You edit** the CONTENT section freely
2. **You save** the file  
3. **Tool rebuilds** the INDEX automatically (editor plugin, file watcher, or manual command)
4. **Agents read** the current INDEX for efficient navigation

### Workflow

```
[Human edits CONTENT]
       ↓
[Save file or run: iatf rebuild]
       ↓
[Tool parses CONTENT, generates INDEX]
       ↓
[File now has updated INDEX with correct line numbers]
       ↓
[Agent reads INDEX for navigation]
```

This is similar to:
- `package.json` → `package-lock.json` (npm)
- Markdown with auto-generated table of contents
- Protobuf files → generated code

## 1. File Structure

An IATF file consists of three parts in order:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HEADER         â”‚  (Required)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   INDEX          â”‚  (Auto-generated)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   CONTENT        â”‚  (Source of Truth)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Important**: The CONTENT section is the source of truth. The INDEX section is auto-generated by parsing tools and should not be manually edited. This ensures line numbers and metadata remain accurate as content changes.

## 2. Header Section

### 2.1 Format Declaration

The file MUST begin with a format declaration:

```
:::IATF/1.0
```

- `:::` is the header marker
- `IATF` is the format identifier
- `/1.0` is the version number

### 2.2 Metadata Fields

Following the declaration, optional metadata fields can appear:

```
@field-name: field value
```

#### Reserved Field Names

| Field | Description | Example |
|-------|-------------|---------|
| `@title` | Document title | `@title: API Documentation` |
| `@modified` | Last modified date | `@modified: 2025-01-20` |
| `@total-words` | Total word count | `@total-words: 15420` |
| `@total-sections` | Number of sections | `@total-sections: 24` |

## 3. Index Section

### 3.1 Index Delimiter

The index section begins with:

```
===INDEX===
<!-- AUTO-GENERATED - DO NOT EDIT MANUALLY -->
<!-- Generated: 2025-01-19T10:30:00Z -->
<!-- Content-Hash: sha256:a7f3b9c -->
```

**Generation Metadata** (required for auto-generated files):
- `<!-- AUTO-GENERATED - DO NOT EDIT MANUALLY -->` marker warns users not to edit manually
- `<!-- Generated: TIMESTAMP -->` ISO 8601 timestamp of generation in format `YYYY-MM-DDTHH:MM:SSZ`
- `<!-- Content-Hash: ALGORITHM:HASH -->` truncated hash (7 chars, Git-style) of CONTENT section for staleness detection

### 3.2 Index Entry Syntax

Each index entry follows this format:

```
[level-marker] Title {#id | lines:start-end | words:count}
> Optional summary text (can span multiple lines if indented)
  Created: YYYY-MM-DD | Modified: YYYY-MM-DD (optional)
  Hash: a1b2c3d (optional)
```

#### Level Markers

| Marker | Level | Equivalent |
|--------|-------|------------|
| `#` | 1 | H1 |
| `##` | 2 | H2 |
| `###` | 3 | H3 |
| `####` | 4 | H4 |
| `#####` | 5 | H5 |
| `######` | 6 | H6 |

#### Entry Components

1. **Level Marker** (Required): `#` to `######`
2. **Title** (Required): Human-readable section name
3. **Metadata Block** (Required): `{...}`
   - `#id` (Required): Unique identifier, alphanumeric with hyphens
   - `lines:start-end` (Required): Line range in content section
   - `words:count` (Required): Word count of section content
4. **Summary** (Optional): Lines starting with `>` immediately after entry
5. **Timestamps** (Optional): Line starting with `Created:` / `Modified:`
6. **Hash** (Optional): Line starting with `Hash:` (7-char content hash)

#### Examples

```
# Getting Started {#getting-started | lines:45-120 | words:580}
> Everything you need to begin using the API, including authentication
> setup, first request, and common patterns.

## Installation {#installation | lines:50-75 | words:200}
> Step-by-step installation instructions for all platforms.

## Quick Start {#quick-start | lines:76-120 | words:380}
> Your first API call in under 5 minutes.
```

### 3.3 Hierarchy Rules

1. Sections can be nested (## under #, ### under ##, etc.)
2. Skipping levels is allowed (# followed by ###)
3. Parent sections' line ranges MUST contain children's ranges
4. IDs MUST be unique within the document
5. Implementations may enforce a maximum nesting depth (this project enforces 2 levels)

## 4. Content Section

### 4.1 Content Delimiter

The content section begins with:

```
===CONTENT===
```

### 4.2 Section Blocks

Content is organized into blocks matching index entries:

```
{#section-id}
@summary: Brief description for the index (optional)
@tags: keyword1, keyword2 (optional)
Content goes here...
Multiple lines...
{/section-id}
```

#### Block Rules

1. Opening tag: `{#id}` where id matches an index entry
2. Optional metadata: Lines starting with `@` immediately after opening tag
3. Closing tag: `{/id}` with matching id
4. Blocks can be nested (children inside parents)
5. All content MUST be inside a block

#### Metadata Annotations (optional)

Annotations provide metadata that will be extracted into the INDEX:

```
{#example}
@summary: This appears as the summary in the generated index
@tags: api, authentication, security

Actual content starts here...
{/example}
```

**Reserved annotations**:
- `@summary:` - Description shown in index (can span multiple lines if continued with indentation)
- `@tags:` - Comma-separated keywords for searching

**Automatic Modification Tracking**:
When `iatf rebuild` runs, it automatically updates section modification data stored in the INDEX:
1. Computes a hash of the actual content (excluding metadata annotations)
2. Compares with the stored `Hash:` from the previous INDEX entry
3. If different, updates `Modified:` in the INDEX to today's date
4. Writes the new `Hash:` into the INDEX entry

This allows you to track when sections were last edited without modifying CONTENT.

**Example** (CONTENT):
```
{#intro}
@summary: Introduction guide
# Introduction
Hello world.
{/intro}
```

**Example** (INDEX entry after rebuild):
```
# Introduction {#intro | lines:1-6 | words:3}
> Introduction guide
  Created: 2025-01-20 | Modified: 2025-01-21
  Hash: bf5d286
```

### 4.3 Content Format

Inside blocks, content is **Markdown-compatible**:

```
{#example}
# Example Section

This is **bold** and this is *italic*.

- List item 1
- List item 2

```python
def hello():
    print("Hello, world!")
```

{/example}
```

## 5. Line Numbering (Auto-Generated)

### 5.1 Counting Rules

Line numbers in the INDEX are **absolute file line numbers** (1-indexed from start of file):

1. Line 1 is the first line of the file (`:::IATF/1.0`)
2. Line numbers in INDEX refer to absolute positions in the file
3. Line ranges include section markers `{#id}` and `{/id}`
4. Blank lines are counted
5. Nested sections' ranges fall within their parent's range

**Why absolute numbers?** This allows agents to directly read line ranges without calculating offsets or finding delimiter positions.

### 5.2 Example

```
:::IATF/1.0                          # File line 1
@title: Example                     # File line 2
                                    # File line 3
===INDEX===                         # File line 4
<!-- AUTO-GENERATED -->             # File line 5
# Intro {#intro | lines:10-14}      # File line 6 (ABSOLUTE line numbers)
                                    # File line 7
===CONTENT===                       # File line 8
                                    # File line 9
{#intro}                            # File line 10 â† Start of range
# Introduction                      # File line 11
                                    # File line 12
Welcome to the document.            # File line 13
{/intro}                            # File line 14 â† End of range
```

**Agent workflow:**
1. Read lines 1-20 â†’ Gets INDEX
2. Parse: section `#intro` is at `lines:10-14`
3. Read lines 10-14 â†’ Gets just that section
4. No offset calculation needed!

**Important**: Users never write line numbers manually. Parsers calculate them when regenerating the INDEX.

## 6. Identifiers

### 6.1 ID Format

Valid IDs:
- Start with a letter (a-z, A-Z)
- Contain letters, numbers, hyphens, underscores
- Case-sensitive
- 1-64 characters long

```
Valid:   intro, getting-started, section_1, apiV2Reference
Invalid: 1section, -intro, my section, @special
```

### 6.2 Hierarchical IDs (Optional Convention)

For clarity, child sections MAY use parent prefix:

```
# Parent {#auth | ...}
## Child {#auth-setup | ...}      # Recommended
## Child {#setup | ...}           # Also valid
```

## 7. Escaping

**Note**: Escape character functionality is planned for future versions but not currently implemented in v1.0.0.

### 7.1 Special Characters in Content (Future Enhancement)

If content contains IATF markers, escape with backslash:

```
{#example}
To start a section, use \{#id}
The index delimiter is \===INDEX===
{/example}
```

### 7.2 Literal Braces (Future Enhancement)

Use double braces for literal single braces:

```
{#code}
JavaScript object: {{ key: "value" }}
{/code}
```

**Workaround**: Until escape characters are implemented, avoid using IATF syntax markers (`{#id}`, `{/id}`, `===INDEX===`, `===CONTENT===`) in your content text, or use alternative representations (e.g., code blocks with language-specific escaping).

## 8. Whitespace

1. Blank lines are preserved in content
2. Trailing whitespace on lines is insignificant
3. Index entries MUST be on single lines (except summaries)
4. Two blank lines recommended between major sections

## 9. Encoding

1. Files MUST be UTF-8 encoded
2. BOM (Byte Order Mark) is optional but discouraged
3. Line endings: LF (Unix) preferred, CRLF (Windows) accepted

## 10. File Extension

Recommended extension: `.iatf`

## 11. MIME Type

Proposed: `text/iatf` or `application/x-iatf`

## 12. Validation Rules

A valid IATF file MUST:

1. ✅“ Start with `:::IATF/` declaration
2. ✅“ Have exactly one `===INDEX===` section
3. ✅“ Have exactly one `===CONTENT===` section
4. ✅“ Have INDEX before CONTENT
5. ✅“ Have all IDs in CONTENT be unique
6. ✅“ Have all index IDs match content blocks
7. ✅“ Have properly nested content blocks
8. ✅“ Have INDEX marked as auto-generated
9. ✅“ Have valid content hash (if present)

### 12.1 Index Staleness Detection

Tools should verify INDEX matches CONTENT by:

1. Computing hash of CONTENT section
2. Comparing with `<!-- Content-Hash: ... -->` in INDEX
3. Warning if mismatch detected
4. Offering to rebuild INDEX if stale

### 12.2 Validation Levels

**Level 1 - Structure**: File has required sections in correct order
**Level 2 - Consistency**: All IDs in INDEX exist in CONTENT
**Level 3 - Accuracy**: Line numbers and word counts match actual content (requires parse)
**Level 4 - Freshness**: Content hash matches, INDEX is current

## 13. Minimal Valid File

### 13.1 Hand-Written (Before Indexing)

```
:::IATF/1.0

===CONTENT===

{#main}
# Document
Content here.
{/main}
```

### 13.2 After Auto-Indexing

```
:::IATF/1.0

===INDEX===
<!-- AUTO-GENERATED - DO NOT EDIT MANUALLY -->
<!-- Generated: 2025-01-19T10:30:00Z -->
<!-- Content-Hash: sha256:9f86d081... -->

# Document {#main | lines:1-4 | words:2}

===CONTENT===

{#main}
# Document
Content here.
{/main}
```

**Note**: The INDEX section is optional in hand-written files. Parsing tools will generate it when needed. The `graph` command requires an INDEX section and will fail if it is missing.

## 13A. Section References

### 13A.1 Reference Syntax

Sections can reference other sections using the `{@section-id}` syntax:

```
{#intro}
# Introduction

See {@auth} for authentication details.
{/intro}

{#auth}
# Authentication

See {@intro} for context.
{/auth}
```

### 13A.2 Reference Rules

| Rule | Behavior |
|------|----------|
| **Syntax** | `{@section-id}` |
| **Self-reference** | **Error** - A section cannot reference itself |
| **Missing target** | **Error** - Reference must point to existing section |
| **Circular refs** | **Allowed** - A→B→A is valid |
| **Inside code blocks/spans** | **Ignored** - References inside fenced code blocks (```) are not validated |
| **INDEX impact** | None - References do not affect INDEX generation |

**Code block rule:** Only lines that are exactly three backticks (```), with no extra characters, open/close a fenced code block. Any other number of backticks is treated as normal text.

### 13A.3 Validation

References are validated during:
- `iatf rebuild` - Fails with error if invalid references found
- `iatf validate` - Reports reference errors in the validation output

**Example validation output:**
```
✗ 2 reference error(s) found:
  - Reference {@missing} at line 45: target section does not exist
  - Reference {@self} at line 50: self-reference not allowed
```

### 13A.4 Rendering and Display

References are plain text markers. Tools MUST NOT auto-expand or inline referenced section content during `read`, `rebuild`, or `validate`. UI clients MAY render references as links, but the underlying file content remains unchanged.

### 13A.5 Literal Reference Syntax (No Escapes in v1.0.0)

The reference parser matches the exact pattern `{@section-id}` in regular CONTENT. v1.0.0 does not provide an escape mechanism outside fenced code blocks (``` on their own line). To document the syntax literally in prose without triggering validation, break the pattern so it no longer matches:

```
Use {@ section-id} (note the space) in prose.
Use { @section-id} (note the space after the brace) in examples.
Use {@section-id } (note the trailing space) in inline code or prose.
```

### 13A.6 Use Cases

1. **Cross-references**: "For more details, see {@advanced-topics}"
2. **Prerequisites**: "This assumes knowledge of {@fundamentals}"
3. **Related sections**: "Related: {@error-handling} and {@performance}"
4. **Navigation hints**: "Next: {@next-section}, Previous: {@prev-section}"

## 13B. Graph Command

### 13B.1 Purpose

The `iatf graph` command displays section-to-section cross-reference relationships in a compact text format, enabling AI agents to:
- Understand document reference topology without reading full content
- Follow reading paths by seeing what sections reference what
- Perform impact analysis when editing sections
- Build mental models of concept dependencies

### 13B.2 Output Format

**Default (outgoing references):**

```text
@graph: filename.iatf

section-id -> referenced-id-1, referenced-id-2
another-section -> referenced-id-3
section-with-no-refs
```

**With `--show-incoming` flag (incoming references):**

```text
@graph: filename.iatf

section-id <- referencer-id-1, referencer-id-2
another-section <- referencer-id-3
section-with-no-incoming
```

**Rules:**
- First line: `@graph: filename.iatf` header
- One line per section in document order
- Outgoing format: `id -> target1, target2, ...` (what this section references)
- Incoming format: `id <- source1, source2, ...` (who references this section)
- Sections without references: `id` (standalone)
- References are comma-separated, sorted alphabetically
- Blank line after header
**Errors:**
- Missing INDEX section: command fails with a non-zero exit code
- Missing CONTENT section: command fails with a non-zero exit code
- No sections in CONTENT: command fails with a non-zero exit code

### 13B.3 Example

**Given IATF file:**
```
{#intro}
See {@setup} and {@auth} for details.
{/intro}

{#setup}
Prerequisites are described in {@intro}.
{/setup}

{#auth}
Authentication setup uses {@setup}.
{/auth}

{#endpoints}
No references to other sections.
{/endpoints}
```

**Output of `iatf graph file.iatf`:**
```text
@graph: file.iatf

intro -> setup, auth
setup -> intro
auth -> setup
endpoints
```

### 13B.4 Relationship to INDEX Command

| Command | Shows | Use Case |
|---------|-------|----------|
| `iatf index` | Hierarchy (parent-child containment) | Understanding document structure |
| `iatf graph` | References (cross-references via `{@id}`) | Understanding conceptual dependencies |

**Hierarchy** is defined by nesting in CONTENT:
```
{#parent}
  {#child}
  {/child}
{/parent}
```

**References** are defined by `{@section-id}` syntax:
```
{#section1}
See {@section2} for details.
{/section1}
```

The `graph` command shows only references, not hierarchy. Use `index` for hierarchy information.

### 13B.5 Token Efficiency

The compact text format is designed for minimal token usage:
- No JSON overhead (brackets, quotes, commas)
- No redundant words ("references", "contains", etc.)
- One line per section maximum
- Simple arrow notation: `->`
- Comma-separated list on same line

**Token comparison for 10 sections with 3 references each:**
- JSON format: ~450 tokens
- Mermaid format: ~350 tokens
- Compact text: ~120 tokens

### 13B.6 Parsing the Output

AI agents can parse the output with simple rules:

```python
def parse_graph_output(output: str) -> dict[str, list[str]]:
    """Parse graph output into section→references map."""
    lines = output.strip().split('\n')
    graph = {}

    for line in lines[2:]:  # Skip header and blank line
        if '->' in line:
            # Has references
            section, refs = line.split(' -> ')
            graph[section] = [r.strip() for r in refs.split(',')]
        else:
            # No references
            graph[line.strip()] = []

    return graph
```

### 13B.7 Use Cases

1. **Reading Path**: "To understand `deployment`, first read `auth` and `api-endpoints`"
2. **Impact Analysis**: "If I change `auth`, which sections are affected?"
3. **Circular Dependencies**: "Detect mutual references between sections"
4. **Isolated Sections**: "Which sections have no connections?"

## 14. Complete Example

### 14.1 Source File (What You Edit)

```
:::IATF/1.0
@title: REST API Guide

===CONTENT===

{#intro}
@summary: Overview of the REST API, its purpose, and key concepts.
# Introduction

This API provides programmatic access to our platform's core functionality.
It follows REST principles and returns JSON responses.

Key concepts:
- All requests require authentication
- Rate limiting applies to all endpoints
- Responses include standard HTTP status codes

Base URL: `https://api.example.com/v1`
{/intro}

{#auth}
@summary: All authentication methods supported by the API.
# Authentication

All API requests must be authenticated using one of the following methods.

{#auth-keys}
@summary: How to generate and use API keys for authentication.
## API Keys

API keys provide simple authentication for server-to-server communication.

To generate a key:
1. Go to Settings â†’ API Keys
2. Click "Generate New Key"
3. Copy and store securely

Include in requests:
```
Authorization: Bearer YOUR_API_KEY
```
{/auth-keys}

{#auth-oauth}
@summary: OAuth 2.0 flow implementation details.
## OAuth 2.0

For user-context requests, use OAuth 2.0 authorization code flow.

1. Redirect user to `/oauth/authorize`
2. User grants permission
3. Exchange code for token at `/oauth/token`
4. Use token in Authorization header

Token refresh is supported via `/oauth/refresh`.
{/auth-oauth}
{/auth}

{#endpoints}
@summary: Complete reference of all available endpoints.
# Endpoints

{#endpoints-users}
@summary: User management endpoints: create, read, update, delete.
## Users

| Method | Path | Description |
|--------|------|-------------|
| GET | /users | List all users |
| POST | /users | Create user |
| GET | /users/:id | Get user |
| PATCH | /users/:id | Update user |
| DELETE | /users/:id | Delete user |
{/endpoints-users}

{#endpoints-resources}
@summary: Resource CRUD operations and batch processing.
## Resources

| Method | Path | Description |
|--------|------|-------------|
| GET | /resources | List resources |
| POST | /resources | Create resource |
| GET | /resources/:id | Get resource |
| PUT | /resources/:id | Replace resource |
| DELETE | /resources/:id | Delete resource |

Batch operations available at `/resources/batch`.
{/endpoints-resources}
{/endpoints}
```

### 14.2 After Running `iatf rebuild`

```
:::IATF/1.0
@title: REST API Guide

===INDEX===
<!-- AUTO-GENERATED - DO NOT EDIT MANUALLY -->
<!-- Generated: 2025-01-19T10:30:00Z -->
<!-- Tool: iatf-tools v1.0.0 -->
<!-- Content-Hash: sha256:7a8b9c0d1e2f3g4h5i6j7k8l9m0n1o2p -->

# Introduction {#intro | lines:1-15 | words:120}
> Overview of the REST API, its purpose, and key concepts.

# Authentication {#auth | lines:17-85 | words:580}
> All authentication methods supported by the API.

## API Keys {#auth-keys | lines:22-50 | words:280}
> How to generate and use API keys for authentication.

## OAuth 2.0 {#auth-oauth | lines:52-85 | words:300}
> OAuth 2.0 flow implementation details.

# Endpoints {#endpoints | lines:87-150 | words:550}
> Complete reference of all available endpoints.

## Users {#endpoints-users | lines:92-120 | words:250}
> User management endpoints: create, read, update, delete.

## Resources {#endpoints-resources | lines:122-150 | words:300}
> Resource CRUD operations and batch processing.

===CONTENT===

{#intro}
@summary: Overview of the REST API, its purpose, and key concepts.
# Introduction

This API provides programmatic access to our platform's core functionality.
It follows REST principles and returns JSON responses.

Key concepts:
- All requests require authentication
- Rate limiting applies to all endpoints
- Responses include standard HTTP status codes

Base URL: `https://api.example.com/v1`
{/intro}

{#auth}
@summary: All authentication methods supported by the API.
# Authentication

All API requests must be authenticated using one of the following methods.

{#auth-keys}
@summary: How to generate and use API keys for authentication.
## API Keys

API keys provide simple authentication for server-to-server communication.

To generate a key:
1. Go to Settings â†’ API Keys
2. Click "Generate New Key"
3. Copy and store securely

Include in requests:
```
Authorization: Bearer YOUR_API_KEY
```
{/auth-keys}

{#auth-oauth}
@summary: OAuth 2.0 flow implementation details.
## OAuth 2.0

For user-context requests, use OAuth 2.0 authorization code flow.

1. Redirect user to `/oauth/authorize`
2. User grants permission
3. Exchange code for token at `/oauth/token`
4. Use token in Authorization header

Token refresh is supported via `/oauth/refresh`.
{/auth-oauth}
{/auth}

{#endpoints}
@summary: Complete reference of all available endpoints.
# Endpoints

{#endpoints-users}
@summary: User management endpoints: create, read, update, delete.
## Users

| Method | Path | Description |
|--------|------|-------------|
| GET | /users | List all users |
| POST | /users | Create user |
| GET | /users/:id | Get user |
| PATCH | /users/:id | Update user |
| DELETE | /users/:id | Delete user |
{/endpoints-users}

{#endpoints-resources}
@summary: Resource CRUD operations and batch processing.
## Resources

| Method | Path | Description |
|--------|------|-------------|
| GET | /resources | List resources |
| POST | /resources | Create resource |
| GET | /resources/:id | Get resource |
| PUT | /resources/:id | Replace resource |
| DELETE | /resources/:id | Delete resource |

Batch operations available at `/resources/batch`.
{/endpoints-resources}
{/endpoints}
```


